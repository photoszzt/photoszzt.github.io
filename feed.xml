<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://photoszzt.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://photoszzt.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-11-24T08:39:31+00:00</updated><id>https://photoszzt.github.io/feed.xml</id><title type="html">Zhiting’s space</title><subtitle>Zhiting&apos;s space is a personal website dedicated to sharing my thoughts, experiences, and projects. </subtitle><entry><title type="html">Magicdom</title><link href="https://photoszzt.github.io/blog/2017/magicdom/" rel="alternate" type="text/html" title="Magicdom"/><published>2017-08-08T23:39:58+00:00</published><updated>2017-08-08T23:39:58+00:00</updated><id>https://photoszzt.github.io/blog/2017/magicdom</id><content type="html" xml:base="https://photoszzt.github.io/blog/2017/magicdom/"><![CDATA[<h2 id="motivation">Motivation</h2> <p>DOM is the API that allows JavaScript to interact with HTML documents. The object that is a part of the DOM API is usually implemented as heap allocated C++/Rust object for most browsers. For JavaScript to interact with these objects, it needs to go through a wrapper called a reflector that gives JavaScript code access to the DOM object. For example, the DOM objects and reflectors on Servo is shown in Figure 1.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/magicdom/reflector-480.webp 480w,/assets/img/magicdom/reflector-800.webp 800w,/assets/img/magicdom/reflector-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/magicdom/reflector.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> DOM Object and Reflector </div> <p>The reflector is a JSObject managed by SpiderMonkey. There’s a pointer stored in one of the inline slots which point back to the heap allocated DOM object.</p> <p>There is a couple downside for this implementation, but the biggest problem is performance:</p> <ul> <li><strong>Type conversion</strong> For most browsers that employ this design, the API is implemented in native code. Since native code and JavaScript use different types, expensive conversions have to perform to convert JavaScript values into equivalent native types. For function return, native types then need to be converted to JS values. One extreme example is converting Rust Vec to/from JavaScript Array. Each conversion requires a deep copy of the data structure which is very costly.</li> <li><strong>JIT Optimization</strong> Native function is opaque to JavaScript JIT, which makes it difficult to do optimizations specific to the calling code.</li> </ul> <p>These problems can be mitigated to some degree. Conversions can be made cheaper. Hints can be given to the JIT to perform some limited optimization, for example the pure annotation on WebIDL for the DOM accessors.</p> <h2 id="magicdom">MagicDOM</h2> <p>Based on the observation, instead of storing the fields of DOM in a separate heap allocated object, MagicDOM stores all of the fields in the reflector (Figure 2).</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/magicdom/transform-480.webp 480w,/assets/img/magicdom/transform-800.webp 800w,/assets/img/magicdom/transform-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/magicdom/transform.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> MagicDOM </div> <p>From Figure 2, all of the fields are stored in the reserved slots in the JSObject. There are 16 inline slots which store at the struct of JSObject<sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>. If more slots are needed, data will be stored in dynamic slots. In total, at most 255 slots can be used.</p> <p>Data stores in the slots would be in <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/JSAPI_Reference/JS::Value">JSValues</a> rather than native types provide opportunities for optimizations. But native code needs to convert JSValues back to native types when working with DOM objects. This is offset by the following:</p> <ul> <li><strong>Conversions</strong> JSValues to/from native types conversions are highly optimized. The JSValues that are stored in slots are well defined which doesn’t need to account for the edge cases. It’s very fast compared to the JSValues got from arbitrary scripts.</li> <li><strong>DOM API</strong> DOM interfaces can be implemented partially or entirely in JavaScript which avoids the cost of conversions and allows JIT optimizations which are limited with native DOM interfaces.</li> </ul> <h2 id="implementation">Implementation</h2> <p>MagicDOM utilizes many Rust features to reduce the engineering efforts and makes the implementation easy to adapt to use cases other than DOM. The code is open source at https://github.com/fitzgen/mozjs/tree/magic-dom</p> <h3 id="mix-native-and-javascript-data-types">Mix native and JavaScript data types</h3> <p>MagicDOM allows fields to have either Rust type or JavaScript side type as shown in the code snippet below. Node has both Rust type fields like u16 and Vec<Node> and JavaScript side type fields like JSString. To help the conversion between Rust and JavaScript type, two traits are implemented.</Node></p> <ul> <li><strong>ToFromJSConvertible</strong> This trait defines methods that convert the Rust type to/from JavaScript type. Most of the Rust primitive types have implemented it. Rust Vec also implements this trait to convert to the corresponding JavaScript type, JSArray and it’s doing a deep copy for conversion.</li> <li><strong>ToFromJSSlots</strong> This trait defines methods that stores data into and retrieve data back from the slot. All of the primitive type in Rust implements this trait. Unlike the above trait, the fat pointer of Vec (raw pointer, length, and capacity) is stored in three separate slots which avoid the deep copy.</li> </ul> <pre><code class="language-Rust">struct Node_struct {
    node_type: u16,
    node_name: *mut JSString,
    base_uri: *mut JSString,
    is_connected: bool,
    node_value: *mut JSString,
    text_content: *mut JSString,
    child_nodes: Vec&lt;Node&gt;,
}
</code></pre> <h3 id="inheritance">Inheritance</h3> <p>To implement inheritance, MagicDOM embeds all the slots from parent class into the current class. Below is an example of a class that has inheritance. The parent class inheritance has to be embedded in the first field of the current class. All the slots that belong to the current class come after the parent class slots.</p> <pre><code class="language-Rust">struct Element_spec {
    _inherit: node::Node,
    local_name: *mut JSString,
    tag_name: *mut JSString,
    namespace: *mut JSString,
    prefix: *mut JSString,
    id: *mut JSString,
    attrs: Vec&lt;attr::Attr&gt;,
};
</code></pre> <h3 id="code-generation-using-procedure-macro-and-macro-rules">Code Generation using procedure macro and macro rules</h3> <p>For the DOM accessors, it needs to know where the fields are stored in the slots. Not all fields occupy the same number of slots. With object inheritance, the developer needs to keep track of the number of slots to shift. It’s very tedious for a human to write all the accessors and most of these methods have similar structures.</p> <p>MagicDOM uses Rust’s <a href="https://github.com/rust-lang/rfcs/blob/master/text/1566-proc-macros.md">procedure macro</a> and macro rules to solve this problem. Given a spec like the following code snippet,</p> <pre><code class="language-Rust">#[derive(MagicDOM)]
struct Element_spec {
    _inherit: node::Node,
    local_name: *mut JSString,
    tag_name: *mut JSString,
    namespace: *mut JSString,
    prefix: *mut JSString,
    id: *mut JSString,
    attrs: Vec&lt;attr::Attr&gt;,
};
</code></pre> <p>the #[derive(MagicDOM)] transform the above code into the following code snippet.</p> <pre><code class="language-Rust">pub struct Element {
    object: *mut JSObject,
}
</code></pre> <p>and generates the following implementations:</p> <ul> <li>Getter (Rust and self-hosted JavaScript)</li> <li>Setter (Rust and self-hosted JavaScript)</li> <li>Constructor (Rust)</li> <li>Trait implementations that stores and retrieves MagicDOM from slots</li> </ul> <p>The slot number is calculated when generating the getter and setter. To help to calculate the slot number in face of inheritance, all types including MagicDOM implements a Trait, NumSlots, that returns the number of slots occupied by this type. The MagicDOM implementation of this trait is also auto generated. There are also other helper methods and trait implementation generated to aid code generation or better operate with SpiderMonkey GC. More details are available in the <a href="https://github.com/fitzgen/mozjs/blob/magic-dom/mozjs/js/rust/magic_codegen/src/lib.rs">source code</a>.</p> <h2 id="evaluation">Evaluation</h2> <p>To evaluate the performance of MagicDOM, a few <a href="http://dromaeo.com/?dom">Dromeao</a> DOM Core tests are ported as MagicDOM currently doesn’t implement all of the DOM API and not integrated with any browser yet. MagicDOM is evaluated with three implementations.</p> <ul> <li><strong>Selfhosted</strong>: Self-hosted JavaScript storing JavaScript values</li> <li><strong>JS native</strong>: Rust native code storing JavaScript values</li> <li><strong>Rust</strong>: Rust native code storing Rust values</li> </ul> <p>Not all tests have all three implementations and some test has more test cases that will be described in the corresponding section.</p> <h3 id="getid">GetId</h3> <p>This method is tested by calling 102400 times in a loop and measure the total time. The normal js test case is the following:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span><span class="na">id</span><span class="p">:</span> <span class="dl">"</span><span class="s2">jaz</span><span class="dl">"</span><span class="p">};</span>
    <span class="k">for </span><span class="p">(</span> <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">num</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">ret</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div> <p>The normal js is not equivalent to the self-hosted JavaScript but it’s a lower bound to see how well the JIT can optimize the code.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/magicdom/getid-480.webp 480w,/assets/img/magicdom/getid-800.webp 800w,/assets/img/magicdom/getid-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/magicdom/getid.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> GetId </div> <p>From Figure 3, we can see that the self-hosted JavaScript is done better than the js native. Here the id is stored as JSString.</p> <h3 id="setid">SetId</h3> <p>This method is tested by calling 102400 times in a loop and measure the total time. The normal js test case is the following:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span><span class="na">id</span><span class="p">:</span> <span class="dl">"</span><span class="s2">jaz</span><span class="dl">"</span><span class="p">};</span>
    <span class="k">for </span><span class="p">(</span> <span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">num</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">a</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">caz</span><span class="dl">"</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/magicdom/setid-480.webp 480w,/assets/img/magicdom/setid-800.webp 800w,/assets/img/magicdom/setid-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/magicdom/setid.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> SetId </div> <p>From Figure 4, SetId is also doing better. After showing benefits for simple methods, let’s look at some complex methods.</p> <h3 id="getattributes">GetAttributes</h3> <p>This method is tested by calling 102400 times in a loop and measure the total time.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/magicdom/getattributes-480.webp 480w,/assets/img/magicdom/getattributes-800.webp 800w,/assets/img/magicdom/getattributes-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/magicdom/getattributes.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> GetAttributes </div> <p>Selfhosted method performs pretty poor. In this method, the attr array is implemented using Vec for Rust type and JSArrayObject for JavaScript type. For this method, the cost of VM call from the JavaScript side to native side is amortized by the fast native implementation.</p> <h3 id="setattributes">SetAttributes</h3> <p>This method is tested by calling 102400 times in a loop and measure the total time. Self-hosted JavaScript implementation is not available for this test. SetAttributes needs to create a new Attr when there’s no attr matched with the name. There’s no way in SpiderMonkey now to support this. But there are <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1226551">two</a> <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1226261">patches</a> in review trying to address this problem.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/magicdom/setattributes-480.webp 480w,/assets/img/magicdom/setattributes-800.webp 800w,/assets/img/magicdom/setattributes-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/magicdom/setattributes.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> SetAttributes </div> <h3 id="appendchilds">AppendChilds</h3> <p>This method is tested by appending 2000 elements on a node in one trial, running 1024 trials in a loop and measuring the total time.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/magicdom/appendchild-480.webp 480w,/assets/img/magicdom/appendchild-800.webp 800w,/assets/img/magicdom/appendchild-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/magicdom/appendchild.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> AppendChilds </div> <p>From Fiture 7, the js native implementation is very slow. After benchmarking the individual SpiderMonkey function it calls, the JS_SetElement is the root cause. The time it takes to return from this function is increasing with the length of the array which is quiet surprise. From its name, it should be O(1) not O(n). Following the call train, it traces to the <a href="http://searchfox.org/mozilla-central/source/js/src/vm/NativeObject.cpp#2771">NativeSetProperty</a> function. Ideally, we should use a <a href="http://searchfox.org/mozilla-central/source/js/src/jsapi.h">JSAPI</a> function that eventually leads to <a href="http://searchfox.org/mozilla-central/source/js/src/vm/NativeObject.h#1145">setDenseElement</a> which is O(1). Right now, there’s no JSAPI for it.</p> <h2 id="discussion">Discussion</h2> <p>Based on the above experiments, we can see that MagicDOM shows benefits for simple get/set methods. We still need more investigation on JIT to speed up the self-hosted JavaScript. For the complex method, self-hosted JavaScript doesn’t show too much edge there. But this may due to my unfamiliar with the JIT and JavaScript features and I think it could be improved.</p> <p>This framework could be also used to define a general data structure to use in the non-browser use cases.</p> <p>Using self-hosted JavaScript code is not easy. Those code needs to compile with the SpiderMonkey and the generated JavaScript code also needs to manually copy and paste into the Utilities.js. The flow of generating JavaScript code could also be improved. Currently, all the generated JavaScript code are in one line and before putting those in SpiderMonkey, a sed script needs to run to separate the lines.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:1"> <p>We cannot add more inline slots right now as it’s limited by the <a href="http://searchfox.org/mozilla-central/source/mfbt/EnumSet.h#27">EnumSet</a> which only allows 32 bits and AllocKind already using all of the bits. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div>]]></content><author><name></name></author><category term="web"/><category term="web"/><summary type="html"><![CDATA[browser dom implementation]]></summary></entry></feed>