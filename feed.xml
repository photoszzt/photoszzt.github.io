<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://photoszzt.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://photoszzt.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-11-28T06:39:13+00:00</updated><id>https://photoszzt.github.io/feed.xml</id><title type="html">Zhiting’s space</title><subtitle>Zhiting&apos;s space is a personal website dedicated to sharing my thoughts, experiences, and projects. </subtitle><entry><title type="html">ByteRobust</title><link href="https://photoszzt.github.io/blog/2025/byteroburst/" rel="alternate" type="text/html" title="ByteRobust"/><published>2025-11-22T23:39:58+00:00</published><updated>2025-11-22T23:39:58+00:00</updated><id>https://photoszzt.github.io/blog/2025/byteroburst</id><content type="html" xml:base="https://photoszzt.github.io/blog/2025/byteroburst/"><![CDATA[<h3 id="robust-llm-training-infrastructure-at-bytedance-link">Robust LLM Training Infrastructure at ByteDance <a href="https://arxiv.org/abs/2509.16293">link</a></h3> <p>Control plane</p> <ol> <li>Robust controller <ol> <li>Robust controller react to events from proactive realtime check: <ol> <li>High confidence event for a specific machine: force drain node, evict the machine, skip stop time diagnostics <ol> <li>GPU unavailability</li> <li>Disk fault</li> </ol> </li> <li>Network issue: tolerate several alerts before evict the machine. Policy: twice within 5 mins empirically <ol> <li>NIC and Network switch flapping can auto recover</li> </ol> </li> <li>If the restarted job fails again after machine eviction, it goes to a stop-time check procedure.</li> </ol> </li> <li>Robust controller analyze the logs <ol> <li>User space error: traceable to specific code modules from logs and exit codes, python exception -&gt; code rollback</li> <li>Training crashes/abnormal metrics, e.g., NaN losses, arise without a clear culprit -&gt; stop time check</li> <li>Performance anomalies: 0 RDMA traffic within 10 mins, low TensorCore utilization -&gt; aggregation analysis</li> </ol> </li> </ol> </li> <li>Runtime analyzer <ol> <li>Aggregation analysis <ol> <li>Parses process trees in each training pod to identify training related processes (torchrun, dataloader, checkpoint process)</li> <li>Stack traces from these identified processes are aggregated into multiple groups via string matching to differentiate abnormal sources <ol> <li>The dominant groups are deemed healthy.</li> <li>Remaining groups are classified as outliers.</li> </ol> </li> <li>Find shared parallel groups for those outliers and isolate the corresponding machines</li> </ol> </li> <li>Fail slow (MFU decline): <ol> <li>Repeat aggregation every 10s, flag the parallel group with the most outliers at each round.</li> <li>Parallel group with the highest cumulative flag count across 5 rounds is marked as the degrader for over-eviction.</li> </ol> </li> </ol> </li> </ol> <p>Data plane (Robust agent in each training pod)</p> <ol> <li>Monitor <ol> <li>System inspection (Proactive realtime check): <ol> <li>Network: NIC down or jitter, packet loss rate, switches down</li> <li>GPU: status of DCGM service, PCIe bandwidth, memory row remapping, and GPU temperature, etc.</li> <li>Host: OS kernel event (Xid in dmesg)</li> </ol> </li> <li>Metics collection <ol> <li>Workload specific training metrics from wandb: loss, gradient norm, MFR, etc <ol> <li>Fatal signal: 5× increase in loss/gradient norms, NaN values</li> </ol> </li> <li>stdout/stderr logs and process exit codes, which serve as hints for diagnostics</li> <li>Events: Significant declines serve as a signal for potential job hangs and MFU declines. <ol> <li>CUDA</li> <li>RDMA: traffic</li> <li>Host</li> <li>Storage</li> </ol> </li> </ol> </li> </ol> </li> <li>Diagnoser <ol> <li>NaN loss diagnosis <ol> <li>Standard GPU and network tests first (EUD and NCCL tests). <ol> <li>Intra machine all-to-all test to verify bandwidth</li> <li>Inter machine all-gather NCCL test to verify connectivity and integrity of data transfer with “neighboring” machines.</li> </ol> </li> <li>Bitwise alignment test <ol> <li>Each machine initiates a reference model whose structure matches that of the target training job (dense models or MoE models).</li> <li>Load predefined weights, employs a specific parallelism configuration (e.g., TP=2, PP=2, DP=2 or EP=2, PP=2, DP=2), and executes one training step on fixed input to ensure reproducibility.</li> <li>The outputs from all machines are collected and analyzed to verify bit-wise accuracy.</li> <li>Machines that yield incorrect results are promptly isolated and removed.</li> <li>If this test does not identify any defective machines, reattempt and rollback are sequentially employed to settle potential transient failures and human errors.</li> </ol> </li> </ol> </li> <li>Job hang and MFU declines</li> </ol> </li> <li>On demand tracer</li> <li>CKPT manager</li> </ol>]]></content><author><name></name></author><category term="paper-review"/><category term="paper-review"/><summary type="html"><![CDATA[Robust LLM Training Infrastructure at ByteDance]]></summary></entry><entry><title type="html">Minder</title><link href="https://photoszzt.github.io/blog/2025/minder/" rel="alternate" type="text/html" title="Minder"/><published>2025-11-22T23:39:58+00:00</published><updated>2025-11-22T23:39:58+00:00</updated><id>https://photoszzt.github.io/blog/2025/minder</id><content type="html" xml:base="https://photoszzt.github.io/blog/2025/minder/"><![CDATA[<h3 id="minder-faulty-machine-detection-for-large-scale-distributed-model-training-link">Minder: Faulty Machine Detection for Large-scale Distributed Model Training <a href="https://arxiv.org/pdf/2411.01791">link</a></h3> <ul> <li> <p>Challenges to solve</p> <ol> <li>Any machine could fail in various ways</li> <li>The normal state of a monitoring metric is task-dependent</li> <li>The correlation between fault types and monitoring metrics is not necessarily one-to-one</li> <li>Noises exist in time series monitoring data</li> </ol> </li> <li> <p>Solution proposed by Minder</p> <ol> <li>Machine level similarity: For challenge 1 and 2, if a machine undergoes a fault, its monitoring data will display distinctive differences, offering an opportunity for detection.</li> <li>Machine level continuity: For challenge 2, most abnormal patterns last for over 5min. if we recognize a machine displaying such dissimilarity continuously for a period, the machine may be faulty.</li> <li>Individual Learning-Based Denoising Models for Each Monitoring Metric: <ul> <li>For challenge 4, variational autoencoders can learn embedding schemes that can infer the generation factors for most of the training data.</li> </ul> </li> </ol> </li> <li> <p>Metrics to monitor (bold are used in detection, others are collected but not used):</p> <ol> <li><strong>CPU Usage</strong>: Percentage of CPU time being used.</li> <li><strong>PFC Tx Packet Rate</strong>: Periodic counts of PFC packets sent by RDMA-enabled devices. - RoCE only?</li> <li><strong>GPU Duty Cycle</strong>: Percentage of time over the past sample period when the accelerator is active.</li> <li><strong>GPU Power Draw</strong>: Periodic counts of the GPU power consumption.</li> <li><strong>GPU Tensor Core Activity</strong>: Percentage of cycles when the tensor (HMMA / IMMA) pipe is active.</li> <li><strong>GPU Graphics Engine Activity</strong>: Percentage of time when any portion of the graphics or compute engines are active.</li> <li><strong>GPU NVLink Bandwidth</strong>: The rate of data transmitted/received over an NVLink.</li> <li>Memory Usage: Percentage of memory being used.</li> <li>Disk Usage: Percentage of storage space being used on a disk.</li> <li>TCP Throughput: Periodic counts of the amount of TCP data being transmitted by a NIC.</li> <li>TCP+RDMA Throughput: Periodic counts of the amount of TCP and RDMA data being transmitted by an NIC.</li> <li>GPU Memory Used: The amount of GPU memory being used by processes.</li> <li>GPU Temperature: The temperature of a GPU while it is operating, measured in degrees Celsius.</li> <li>GPU SM Activity: Averaged percentage of time when at least one warp is active on a multiprocessor.</li> <li>GPU Clocks: The clock speed of a GPU, reflecting the frequency of the GPU’s processor.</li> <li>GPU FP Engine Activity: Percentage of cycles when the FP pipe is active.</li> <li>GPU Memory Bandwidth Utilization: Percentage of cycles when data is sent to or received from the device memory.</li> <li>PCIe Bandwidth: The rate of data transmitted/received over the PCIe bus.</li> <li>PCIe Usage: Percentage of the bandwidth being used on the PCIe bus.</li> <li>ECN Packet Rate: Periodic counts of ECN packets transmitted/received by a NIC.</li> <li>CNP Packet Rate: Periodic counts of CNP packets transmitted/received by a NIC.</li> </ol> </li> <li> <p>Analytics:</p> <ol> <li>Metrics data are grouped into a time window.</li> <li>Within the time window, align sample points across all sampled machines. If sample data points are missed, use data from nearest sampling time for padding.</li> <li> <p>Normalize data points based on upper and lower limits of each metric with min-max normalization.</p> \[x' = \frac{x - min}{max - min}\] </li> <li>Fed the normalized data to the corresponding metric LSTM-VAE model to get the embedding.</li> <li>Calculate pairwise Euclidean distances of embeddings between every two machines.</li> <li>For each machine, get the sum of the distances to other machines</li> <li> <p>Calculate the normal/z-score of the sum of the distances of each machine. avg(x) is the average of x and std(x) is the standard deviation of x.</p> \[z =\frac{x - avg(x)}{std(x)}\] </li> <li>The machine with the maximum normal score is probably the faulty one. If the maximum normal score is higher than a similarity threshold, the machine is assumed as a candidate of the time window</li> <li>Continuity check: shifts the time window with one data sample to detect the potentially faulty machine for new windows. If the same machine is detected with consecutive times that exceed a continuity threshold, 4mins, it is considered a truly faulty machine.</li> </ol> </li> </ul>]]></content><author><name></name></author><category term="paper-review"/><category term="paper-review"/><summary type="html"><![CDATA[Minder Faulty Machine Detection for Large-scale Distributed Model Training]]></summary></entry><entry><title type="html">Magicdom</title><link href="https://photoszzt.github.io/blog/2017/magicdom/" rel="alternate" type="text/html" title="Magicdom"/><published>2017-08-08T23:39:58+00:00</published><updated>2017-08-08T23:39:58+00:00</updated><id>https://photoszzt.github.io/blog/2017/magicdom</id><content type="html" xml:base="https://photoszzt.github.io/blog/2017/magicdom/"><![CDATA[<h2 id="motivation">Motivation</h2> <p>DOM is the API that allows JavaScript to interact with HTML documents. The object that is a part of the DOM API is usually implemented as heap allocated C++/Rust object for most browsers. For JavaScript to interact with these objects, it needs to go through a wrapper called a reflector that gives JavaScript code access to the DOM object. For example, the DOM objects and reflectors on Servo is shown in Figure 1.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/magicdom/reflector-480.webp 480w,/assets/img/magicdom/reflector-800.webp 800w,/assets/img/magicdom/reflector-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/magicdom/reflector.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> DOM Object and Reflector </div> <p>The reflector is a JSObject managed by SpiderMonkey. There’s a pointer stored in one of the inline slots which point back to the heap allocated DOM object.</p> <p>There is a couple downside for this implementation, but the biggest problem is performance:</p> <ul> <li><strong>Type conversion</strong> For most browsers that employ this design, the API is implemented in native code. Since native code and JavaScript use different types, expensive conversions have to perform to convert JavaScript values into equivalent native types. For function return, native types then need to be converted to JS values. One extreme example is converting Rust Vec to/from JavaScript Array. Each conversion requires a deep copy of the data structure which is very costly.</li> <li><strong>JIT Optimization</strong> Native function is opaque to JavaScript JIT, which makes it difficult to do optimizations specific to the calling code.</li> </ul> <p>These problems can be mitigated to some degree. Conversions can be made cheaper. Hints can be given to the JIT to perform some limited optimization, for example the pure annotation on WebIDL for the DOM accessors.</p> <h2 id="magicdom">MagicDOM</h2> <p>Based on the observation, instead of storing the fields of DOM in a separate heap allocated object, MagicDOM stores all of the fields in the reflector (Figure 2).</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/magicdom/transform-480.webp 480w,/assets/img/magicdom/transform-800.webp 800w,/assets/img/magicdom/transform-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/magicdom/transform.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> MagicDOM </div> <p>From Figure 2, all of the fields are stored in the reserved slots in the JSObject. There are 16 inline slots which store at the struct of JSObject<sup id="fnref:1"><a href="#fn:1" class="footnote" rel="footnote" role="doc-noteref">1</a></sup>. If more slots are needed, data will be stored in dynamic slots. In total, at most 255 slots can be used.</p> <p>Data stores in the slots would be in <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Projects/SpiderMonkey/JSAPI_Reference/JS::Value">JSValues</a> rather than native types provide opportunities for optimizations. But native code needs to convert JSValues back to native types when working with DOM objects. This is offset by the following:</p> <ul> <li><strong>Conversions</strong> JSValues to/from native types conversions are highly optimized. The JSValues that are stored in slots are well defined which doesn’t need to account for the edge cases. It’s very fast compared to the JSValues got from arbitrary scripts.</li> <li><strong>DOM API</strong> DOM interfaces can be implemented partially or entirely in JavaScript which avoids the cost of conversions and allows JIT optimizations which are limited with native DOM interfaces.</li> </ul> <h2 id="implementation">Implementation</h2> <p>MagicDOM utilizes many Rust features to reduce the engineering efforts and makes the implementation easy to adapt to use cases other than DOM. The code is open source at https://github.com/fitzgen/mozjs/tree/magic-dom</p> <h3 id="mix-native-and-javascript-data-types">Mix native and JavaScript data types</h3> <p>MagicDOM allows fields to have either Rust type or JavaScript side type as shown in the code snippet below. Node has both Rust type fields like u16 and Vec<Node> and JavaScript side type fields like JSString. To help the conversion between Rust and JavaScript type, two traits are implemented.</Node></p> <ul> <li><strong>ToFromJSConvertible</strong> This trait defines methods that convert the Rust type to/from JavaScript type. Most of the Rust primitive types have implemented it. Rust Vec also implements this trait to convert to the corresponding JavaScript type, JSArray and it’s doing a deep copy for conversion.</li> <li><strong>ToFromJSSlots</strong> This trait defines methods that stores data into and retrieve data back from the slot. All of the primitive type in Rust implements this trait. Unlike the above trait, the fat pointer of Vec (raw pointer, length, and capacity) is stored in three separate slots which avoid the deep copy.</li> </ul> <pre><code class="language-Rust">struct Node_struct {
    node_type: u16,
    node_name: *mut JSString,
    base_uri: *mut JSString,
    is_connected: bool,
    node_value: *mut JSString,
    text_content: *mut JSString,
    child_nodes: Vec&lt;Node&gt;,
}
</code></pre> <h3 id="inheritance">Inheritance</h3> <p>To implement inheritance, MagicDOM embeds all the slots from parent class into the current class. Below is an example of a class that has inheritance. The parent class inheritance has to be embedded in the first field of the current class. All the slots that belong to the current class come after the parent class slots.</p> <pre><code class="language-Rust">struct Element_spec {
    _inherit: node::Node,
    local_name: *mut JSString,
    tag_name: *mut JSString,
    namespace: *mut JSString,
    prefix: *mut JSString,
    id: *mut JSString,
    attrs: Vec&lt;attr::Attr&gt;,
};
</code></pre> <h3 id="code-generation-using-procedure-macro-and-macro-rules">Code Generation using procedure macro and macro rules</h3> <p>For the DOM accessors, it needs to know where the fields are stored in the slots. Not all fields occupy the same number of slots. With object inheritance, the developer needs to keep track of the number of slots to shift. It’s very tedious for a human to write all the accessors and most of these methods have similar structures.</p> <p>MagicDOM uses Rust’s <a href="https://github.com/rust-lang/rfcs/blob/master/text/1566-proc-macros.md">procedure macro</a> and macro rules to solve this problem. Given a spec like the following code snippet,</p> <pre><code class="language-Rust">#[derive(MagicDOM)]
struct Element_spec {
    _inherit: node::Node,
    local_name: *mut JSString,
    tag_name: *mut JSString,
    namespace: *mut JSString,
    prefix: *mut JSString,
    id: *mut JSString,
    attrs: Vec&lt;attr::Attr&gt;,
};
</code></pre> <p>the #[derive(MagicDOM)] transform the above code into the following code snippet.</p> <pre><code class="language-Rust">pub struct Element {
    object: *mut JSObject,
}
</code></pre> <p>and generates the following implementations:</p> <ul> <li>Getter (Rust and self-hosted JavaScript)</li> <li>Setter (Rust and self-hosted JavaScript)</li> <li>Constructor (Rust)</li> <li>Trait implementations that stores and retrieves MagicDOM from slots</li> </ul> <p>The slot number is calculated when generating the getter and setter. To help to calculate the slot number in face of inheritance, all types including MagicDOM implements a Trait, NumSlots, that returns the number of slots occupied by this type. The MagicDOM implementation of this trait is also auto generated. There are also other helper methods and trait implementation generated to aid code generation or better operate with SpiderMonkey GC. More details are available in the <a href="https://github.com/fitzgen/mozjs/blob/magic-dom/mozjs/js/rust/magic_codegen/src/lib.rs">source code</a>.</p> <h2 id="evaluation">Evaluation</h2> <p>To evaluate the performance of MagicDOM, a few <a href="http://dromaeo.com/?dom">Dromeao</a> DOM Core tests are ported as MagicDOM currently doesn’t implement all of the DOM API and not integrated with any browser yet. MagicDOM is evaluated with three implementations.</p> <ul> <li><strong>Selfhosted</strong>: Self-hosted JavaScript storing JavaScript values</li> <li><strong>JS native</strong>: Rust native code storing JavaScript values</li> <li><strong>Rust</strong>: Rust native code storing Rust values</li> </ul> <p>Not all tests have all three implementations and some test has more test cases that will be described in the corresponding section.</p> <h3 id="getid">GetId</h3> <p>This method is tested by calling 102400 times in a loop and measure the total time. The normal js test case is the following:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span> <span class="na">id</span><span class="p">:</span> <span class="dl">"</span><span class="s2">jaz</span><span class="dl">"</span> <span class="p">};</span>
<span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">num</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">ret</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>The normal js is not equivalent to the self-hosted JavaScript but it’s a lower bound to see how well the JIT can optimize the code.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/magicdom/getid-480.webp 480w,/assets/img/magicdom/getid-800.webp 800w,/assets/img/magicdom/getid-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/magicdom/getid.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> GetId </div> <p>From Figure 3, we can see that the self-hosted JavaScript is done better than the js native. Here the id is stored as JSString.</p> <h3 id="setid">SetId</h3> <p>This method is tested by calling 102400 times in a loop and measure the total time. The normal js test case is the following:</p> <div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span> <span class="na">id</span><span class="p">:</span> <span class="dl">"</span><span class="s2">jaz</span><span class="dl">"</span> <span class="p">};</span>
<span class="k">for </span><span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">num</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">a</span><span class="p">.</span><span class="nx">id</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">caz</span><span class="dl">"</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/magicdom/setid-480.webp 480w,/assets/img/magicdom/setid-800.webp 800w,/assets/img/magicdom/setid-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/magicdom/setid.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> SetId </div> <p>From Figure 4, SetId is also doing better. After showing benefits for simple methods, let’s look at some complex methods.</p> <h3 id="getattributes">GetAttributes</h3> <p>This method is tested by calling 102400 times in a loop and measure the total time.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/magicdom/getattributes-480.webp 480w,/assets/img/magicdom/getattributes-800.webp 800w,/assets/img/magicdom/getattributes-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/magicdom/getattributes.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> GetAttributes </div> <p>Selfhosted method performs pretty poor. In this method, the attr array is implemented using Vec for Rust type and JSArrayObject for JavaScript type. For this method, the cost of VM call from the JavaScript side to native side is amortized by the fast native implementation.</p> <h3 id="setattributes">SetAttributes</h3> <p>This method is tested by calling 102400 times in a loop and measure the total time. Self-hosted JavaScript implementation is not available for this test. SetAttributes needs to create a new Attr when there’s no attr matched with the name. There’s no way in SpiderMonkey now to support this. But there are <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1226551">two</a> <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1226261">patches</a> in review trying to address this problem.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/magicdom/setattributes-480.webp 480w,/assets/img/magicdom/setattributes-800.webp 800w,/assets/img/magicdom/setattributes-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/magicdom/setattributes.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> SetAttributes </div> <h3 id="appendchilds">AppendChilds</h3> <p>This method is tested by appending 2000 elements on a node in one trial, running 1024 trials in a loop and measuring the total time.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/magicdom/appendchild-480.webp 480w,/assets/img/magicdom/appendchild-800.webp 800w,/assets/img/magicdom/appendchild-1400.webp 1400w," type="image/webp" sizes="95vw"/> <img src="/assets/img/magicdom/appendchild.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> AppendChilds </div> <p>From Fiture 7, the js native implementation is very slow. After benchmarking the individual SpiderMonkey function it calls, the JS_SetElement is the root cause. The time it takes to return from this function is increasing with the length of the array which is quiet surprise. From its name, it should be O(1) not O(n). Following the call train, it traces to the <a href="http://searchfox.org/mozilla-central/source/js/src/vm/NativeObject.cpp#2771">NativeSetProperty</a> function. Ideally, we should use a <a href="http://searchfox.org/mozilla-central/source/js/src/jsapi.h">JSAPI</a> function that eventually leads to <a href="http://searchfox.org/mozilla-central/source/js/src/vm/NativeObject.h#1145">setDenseElement</a> which is O(1). Right now, there’s no JSAPI for it.</p> <h2 id="discussion">Discussion</h2> <p>Based on the above experiments, we can see that MagicDOM shows benefits for simple get/set methods. We still need more investigation on JIT to speed up the self-hosted JavaScript. For the complex method, self-hosted JavaScript doesn’t show too much edge there. But this may due to my unfamiliar with the JIT and JavaScript features and I think it could be improved.</p> <p>This framework could be also used to define a general data structure to use in the non-browser use cases.</p> <p>Using self-hosted JavaScript code is not easy. Those code needs to compile with the SpiderMonkey and the generated JavaScript code also needs to manually copy and paste into the Utilities.js. The flow of generating JavaScript code could also be improved. Currently, all the generated JavaScript code are in one line and before putting those in SpiderMonkey, a sed script needs to run to separate the lines.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:1"> <p>We cannot add more inline slots right now as it’s limited by the <a href="http://searchfox.org/mozilla-central/source/mfbt/EnumSet.h#27">EnumSet</a> which only allows 32 bits and AllocKind already using all of the bits. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div>]]></content><author><name></name></author><category term="web"/><category term="web"/><summary type="html"><![CDATA[browser dom implementation]]></summary></entry></feed>